#+TITLE: Normalizzazione forte di $\lambda 2 \mu$
#+STARTUP: latexpreview

Dobbiamo vedere che il sistema $\lambda 2 \mu$ sia fortemente normalizzante, utilizzando la consueta tecnica degli insiemi saturi.
Secondo Geuvers, questo risultato, anche se non presente in letteratura, è simile a quanto dimostrato per un differente sistema di tipi ricorsivi da Mendler nel paper "Inductive types and type constraints in the second-order lambda calculus".

** Review del paper di Mendler

*** Struttura generale della dimostrazione
La dimostrazione si articola in una serie di 6 passi:
**** Definizione di $\Xi$
Detto $\mathsf{T}$ l'insieme dei termini fortemente normalizzabili, definiamo $\Xi$ come un reticolo (insieme parzialmente ordinato in cui ogni coppia di elementi ha sia un estremo inferiore che un estremo superiore) completo (ogni suo sottoinsieme ha sia l’inf che il sup) di sottoinsiemi di $\mathsf{T}$.
I tipi vengono modellati come elementi di $\Xi$.
**** Operazioni che modellano $\rightarrow$, $\Delta$, $\mu$ e $\nu$
Abbiamo già tradotto i tipi nel nostro modello, quindi proseguiamo definendo le operazioni su $\Xi$ che modellano le operazioni sui tipi elencate.
**** Creazione di una funzione di interpretazione
Le operazioni che abbiamo definito sopra ci servono per estendere una funzione $\rho : Var \rightarrow \Xi$, a $\llbracket \cdot \rrbracket \rho : Type \rightarrow \Xi$.
**** Definizione di $\lvert a \rvert$
Qui definiamo cosa intendiamo quando diciamo che il termine non tipato $t$ è sostituto di un termine tipato $a$.
**** Definizione di $\vDash a : A$
Ovvero la nostra nozione di verità sui giudizi di tipo, definita come:
$\vDash a : A \equiv \forall \rho, \forall t, \forall a, t \in \llbracket A \rrbracket \rho$
**** $a$ è fortemente normalizzabile se lo è $\lvert a \rvert$
Da questo si può concludere, perché se $\vdash a:A$ allora $\vDash a : A$, quindi $\lvert a \rvert \in \llbracket A \rrbracket \rho$.
Questo per i primi tre punti implica che $\lvert a \rvert$ sia fortemente normalizzabile, quindi per questo lemma lo è anche $a$.
*** Preliminari
**** Descrizione dei tipi
Iniziamo a descrivere i tipi che useremo nella dimostrazione.
Assumiamo un numero infinito di variabili $V_1, V_2, V_3, \dots$, nel seguito useremo $X,Y,Z$ come metavariabili su di esse.

Definiamo cos'è un tipo:
#+BEGIN_QUOTE
- $X$ è un tipo.
- Se $A$ e $B$ sono tipi, lo sono anche $A \rightarrow B$ e $\Delta X.A$ (notiamo che $\Delta X.A$ è la notazione per l'astrazione sui tipi).
- Se $X$ occorre positivamente in $A$, allora $\mu X.A$ e $\nu X.A$ sono tipi.
#+END_QUOTE

Notiamo che gli operatori $\Delta$, $\mu$ e $\nu$ bindano le occorrenze della variabile a cui si riferiscono.
Possiamo allora definire meglio cosa intendiamo con occorrenze positive e negative:
- $X$ occorre positivamente in $A$, ovvero $Pos(A,X)$ se ogni occorrenza libera di $X$ in $A$ è sul lato sinistro di un numero pari di $\rightarrow$.
- $X$ occorre negativamente in $A$, ovvero $Neg(A,X)$ se ogni occorrenza libera di $X$ in $A$ è sul lato sinistro di un numero dispari di $\rightarrow$.

Come esempio di occorrenze positive e negative, consideriamo gli encoding standard:
$A \times B = \Delta Z. (A \rightarrow B \rightarrow Z) \rightarrow Z$
$A + B = \Delta Z. (A \rightarrow Z) \rightarrow (B \rightarrow Z) \rightarrow Z$
Da cui, contando il numero delle occorrenze sul lato sinistro delle $\rightarrow$, si capisce che una variabile $X$ occorre positivamente in una di queste due formule se occorre positivamente sia in $A$ che in $B$.

Il requisito dell'occorrenza positiva ci interessa perché assicura la monotonicità di certe operazioni sui reticoli completi, e quindi l'esistenza di massimi e minimi punti fissi, che saranno i modelli per i nostri tipi induttivi.

**** Descrizione dei termini tipati
Per ogni termine $\bar{\mu} \equiv \mu X.A$ ho le costanti:
$in^{\bar{\mu}} : A[\bar{\mu}/X] \rightarrow \bar{\mu}$
$R^{\bar{\mu}} : \Delta Y.(\Delta X.(X \rightarrow Y) \rightarrow A \rightarrow Y) \rightarrow \bar{\mu} \rightarrow Y$

La costante $in^{\bar{\mu}}$ ci consente di costruire un termine di tipo $\bar{\mu}$ costruendo un suo unrolling $A[\bar{\mu}/X]$.
La costante $R^{\bar{\mu}}$ è invece un combinatore per l'induzione: dato un tipo $Y$, possiamo costruire una funzione $\bar{\mu} \rightarrow Y$ usando una "ipotesi induttiva" della forma $\Delta X. (X \rightarrow Y) \rightarrow A \rightarrow Y$.
Possiamo pensare a quella funzione come ad una funzione che estende una funzione $X \rightarrow Y$ in una funzione $A \rightarrow Y$.

Dualizzando, per ogni termine $\bar{\nu} \equiv \nu X.A$ ho le costanti:
$out^{\bar{\nu}} : \bar{\nu} \rightarrow A[\bar{\nu}/X]$
$S^{\bar{\nu}} : \Delta Y. (\Delta X. (Y \rightarrow X) \rightarrow Y \rightarrow A) \rightarrow Y \rightarrow \bar{\nu}$

dove $out^{\bar{\nu}}$ rappresenta l'unrolling e $S^{\bar{\nu}}$ è un combinatore per la coinduzione.

**** Regole per l'assegnamento dei tipi:
Abbiamo qui le regole per l'assegnazione dei tipi alle variabili:

\begin{prooftree}
\AxiomC {$$}
\UnaryInfC {$x^A : A$}
\end{prooftree}

Per l'assegnazione dei tipi alle astrazioni, sia su termini che su tipi (nel secondo caso, solo se $X$ non appare libera in $A$ per ogni $x^A$ libero in $B$):

\begin{prooftree}
\AxiomC {$b : B$}
\UnaryInfC {$\lambda x^A.b : A \rightarrow B$}
\end{prooftree}

\begin{prooftree}
\AxiomC {$b : B$}
\UnaryInfC {$\Lambda X.b : \Delta X.B$}
\end{prooftree}

Infine, quelle per l'assegnazione dei tipi alle applicazioni, di nuovo sia per i termini che per i tipi:

\begin{prooftree}
\AxiomC {$c : A \rightarrow B$}
\AxiomC {$a : A$}
\BinaryInfC {$c \: a : B$}
\end{prooftree}

\begin{prooftree}
\AxiomC {$b : \Delta X.B$}
\UnaryInfC {$b \: A : B[A/X]$}
\end{prooftree}

**** Regole di riduzione per i termini tipati
Le prime quattro di queste riduzioni sono le consuete per il lambda-calcolo del secondo ordine;
al solito la seconda e la quarta richiedono rispettivamente che $x^A$ e $X$ non appaiano libere in $a$:

1) $(\lambda x^A.a) \: b \mapsto a[b/x^A]$
2) $\lambda x^A.(a \: x^A) \mapsto a$
3) $(\Lambda X.a) \: B \mapsto a[B/X]$
4) $\Lambda X.(a \: X) \mapsto a$
5) $R^{\bar{\mu}} \: B \: a \: (in^{\bar{\mu}} \: b) \mapsto a \: \bar{\mu} \: (R^{\bar{\mu}} \: B \: a) \: b$
6) $out^{\bar{\nu}}(S^{\bar{\nu}} \: B \: a \: b) \mapsto a \: \bar{\nu} \: (S^{\bar{\nu}} \: B \: a) \: b$

Le ultime due riduzioni riguardano invece i tipi di dato ricorsivi che abbiamo definito:
per la prima, ad esempio, dev'essere:
- $B : Type$
- $a : \Delta X.(X \rightarrow B) \rightarrow A \rightarrow B$
- $in^{\bar{\mu}} \: b : \bar{\mu}$
- $R^{\bar{\mu}} \: B \: a : \bar{\mu} \rightarrow B$

Definiamo anche $a>b$ per dire che $b$ si raggiunge con una sola applicazione di una regola di riduzione ad (un sottotermine di) $a$, mentre con $a >^* b$ intendiamo che $a$ si riduce a $b$ con un numero finito di riduzioni.


